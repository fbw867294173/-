/*分组背包问题

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

输入格式
第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；
输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤100
0<Si≤100
0<vij,wij≤100
输入样例
3 5
2
1 2
2 4
1
3 4
1
4 5
输出样例：
8

思路：
是多重背包的泛化形式。
多重背包中每个组内的物品体积和价值相同，共s个。
分组背包中每个组内的物品体积和价值可能不同，共S个。
但每个物品仍然只能选一次。
做法就是把每一组的物品信息先保存下来，然后按组内的01背包问题求解。
遍历所有组就行了。

*/

#include<iostream>
#include<algorithm>
using namespace std;

const int maxn = 105;
int w[maxn], c[maxn], dp[maxn];

int main() {
	int n, m, q;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		cin >> q;
		for (int j = 0; j < q; j++)cin >> w[j] >> c[j];
		//这里不知道v的下限，所以遍历到0，加一个判断v是否大于w[k]
		for (int v = m; v >= 0; v--)
			for (int k = 0; k < q; k++)
				if(v>=w[k])
					dp[v] = max(dp[v], dp[v - w[k]] + c[k]);
	}
	cout << dp[m] << endl;
	return 0;
}
