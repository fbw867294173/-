/*0-1背包的优化

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 wi，价值是 ci。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 wi,ci，用空格隔开，分别表示第 i 件物品的体积和价值。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤1000
0<vi,wi≤1000
输入样例
4 5
1 2
2 4
3 4
4 5
输出样例：
8

把dp想象成二维矩阵。
注意到在求解每个dp[i][v]时，总是仅需比较它正上方的元素dp[i-1][v]，和左上方的某个元素dp[i-1][v-w]+c。
而在计算i+1时，i-1的那一行又用不到了。也就是说上一轮的结果仅在当前一轮比较过后就没有用处了。
因此可以考虑在空间上进行压缩。去掉第一个参数i，将每一轮计算得到的dp保存下来，留给下一轮使用。
同时下一轮计算后又会将之前的结果覆盖。这样空间复杂度将被压缩成O(m)。
但要注意此时必须逆序遍历V，因为dp[0...v-1]保存的是上一轮的数据。正向遍历时，后面的计算可能会用到本轮的数据儿引发错误。
此时dp[v] = max(dp[v], dp[v - w] + c);

时间复杂度O(mn)
空间复杂度O(n)
*/

#include<iostream>
#include<algorithm>
using namespace std;

const int maxn = 1005;
int dp[maxn]; 

int main() {
	int n, m;
	cin >> n >> m;
	int w, c;
	//i可以从0开始循环
	for (int i = 1; i <= n; i++) {
		cin >> w >> c;
		for (int v = m; v >= w; v--)
			//在此处有不同
			dp[v] = max(dp[v], dp[v - w] + c);
	}
	cout << dp[n][m];
	return 0;
}
