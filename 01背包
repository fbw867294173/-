/*0-1背包

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 wi，价值是 ci。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 wi,ci，用空格隔开，分别表示第 i 件物品的体积和价值。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤1000
0<vi,wi≤1000
输入样例
4 5
1 2
2 4
3 4
4 5
输出样例：
8

思路：
只能选一次，每个物品有选和不选两种可能，故每一种物品都是一个阶段状态。
定义dp[i][v]总体积是v时前i个物品能获得的最大价值，
dp[i][v] = max(dp[i - 1][v], dp[i - 1][v - w[i]] + c [i]);
即不选第i个物品时，状态从dp[i-1][v]转移过来；选第i个物品时，状态从dp[i-1][v-w[i]]转移过来，此时最大价值要加上c[i]。
这样迭代所有的物品，结果即为所求。
时间复杂度O(mn)
空间复杂度O(n)
*/
#include<iostream>
#include<algorithm>
using namespace std;

const int maxn = 1005;
// 注意，全都初始化为0，dp[n][m]表示的是所有总体积<=m的方案中价值最大的，而非总体积恰好是m。
int dp[maxn][maxn]; 

int main() {
	int n, m;
	cin >> n >> m;
	int w, c;
	for (int i = 1; i <= n; i++) {
		cin >> w >> c;
		for (int v = w; v <= m; v++)
			dp[i][v] = max(dp[i - 1][v], dp[i - 1][v - w] + c);
	}
	cout << dp[n][m];
	return 0;
}
